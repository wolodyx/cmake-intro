 # &#128293; Простой проект CMake

В этом разделе мы научимся создавать простой проект программы на Си.


## Проект из одного запускаемого файла

Проект состоит из четырех файлов, расположенных в одном каталоге.
Исходные и заголовочные файлы взяты из примера предыдущего раздела.

```
cmake-project/
├── CMakeLists.txt  (сценарий CMake)
├── main.c          (главный файл с main())
├── hello.c         (доп. функции)
├── print.c         (доп. функции)
├── hello.h         (заголовочный файл к hello.c)
└── print.h         (заголовочный файл к print.c)
```

Файл `CMakeLists.txt` состоит из следующих трех строк или трех команд в терминологии CMake:

```cmake
cmake_minimum_required(VERSION 3.22 FATAL_ERROR)
project(Hello LANGUAGES C)
add_executable(app main.c hello.c print.c)
```

Разберем каждую из этих строк.

Первая команда `cmake_minimum_required(VERSION 3.22 FATAL_ERROR)` указывает на минимально разрешенную версию интерпретатора CMake, необходимую для разбора сценариев этого проекта.
Она указывает, что сценарий CMakeLists.txt требует CMake версии 3.22 или новее.
Если это условие не выполняется, то процесс разбора файла останавливается.

Команда принимает здесь два параметра:
* `VERSION 3.22` -- минимальная версия CMake (3.22);
* `FATAL_ERROR` -- указание, что если версия CMake ниже 3.22, то дальнейший процесс разбора остановится с ошибкой.

```{note}
Фактически в команду передаются три параметра, но первые два связаны в одну логическую группу.
Первый параметр обозначает **ключевое слово**, а второй -- связанное с ним значение.
Это типовой прием CMake для передачи в команду аргументов в виде пары "ключ-значение".
```

Команда `project(Hello LANGUAGES C)` определяет проект и его параметры.
Она принимает два параметра:
* `Hello` задает название проекта;
* `LANGUAGES C` явно указывает, что проект использует только язык C (не C++)

Кроме C/C++ CMake поддерживает такие языки программирования как C#, CUDA, Objective-C, Objective-C++, Fortran, Swift и разные диалекты Assembler'а.
Если `LANGUAGE C` не указан, то CMake решит, что проект использует язык C++ и будет искать компилятор под него.

Команда `add_executable(app main.c hello.c print.c)` добавляет правила сборки исполняемого файла из указанных файлов.
Ее параметры:
* `app` — имя исполняемого файла;
* `main.c hello.c print.c` — список исходных файлов для компиляции

В результате выполнения этой команды в сборке появится цель `app`.
Ее можно собрать отдельно командой `cmake --build . --target app` или `make app`.
В IDE `Visual Studio` эта цель отобразится в виде значка с проектом -- частью решения `Hello`.

```{figure} ./images2/VS2022HelloProjectGui.png
```

Чтобы получить исполняемый файл, запустите в корне проекта следующий ряд команд в командной строке:
```bash
mkdir build
cd build
cmake ..
cmake --build .
./app
```


## Проект из нескольких исполняемых файлов

На следующем шаге мы выделим из исполняемого файла (цели `app`) две разделяемые библиотеки (цели `hello` и `print`).

```{figure} ./images2/targets-hello-world-app.png
```

```cmake
cmake_minimum_required(VERSION 3.22 FATAL_ERROR)
project(Hello LANGUAGES C)
add_library(hello hello.c)
add_library(print print.c)
add_executable(app main.c)
target_link_libraries(app hello print)
```

Что изменилось в файле `CMakeLists.txt` по сравнению с первым вариантом?
Повились команды `add_library` и `target_link_libraries` и изменились параметры команды `add_executable`.
Рассмотрим изменения в файле подробнее.

В этой версии проекта мы добавляем две библиотеки: `hello` на основе исходного кода из `hello.c` и `print` на основе `print.c`.
Эти два файла мы исключаем из параметров команды `add_executable`.

Команда `add_library` добавляет цель, в результате сборки которой появляется библиотека.
Ее параметры:
* `hello` (или `print`) задает имя цели;
* `hello.c` (или `print.c`) задает список исходных файлов для компиляции; в данном случае список состоит из одного файла.

Команда `target_link_libraries` устанавливает зависимость одной цели от другой.
В данном примере показано, что исполняемый файл `app` зависит от библиотек `hello` и `print`.
Эта зависимость показывает, что `app` вызывает функции из `hello` и `print`.

Соберем проект, выполнив из каталога `build` команды

```bash
rm -rf *
cmake ..
cmake --build .
```

На выходе появятся два архива с именами файлов `hello.a` и `print.a`.
Если вы хотите чтобы они были разделяемыми, то на этапе конфигурации передайте CMake переменную `BUILD_SHARED_LIBS=ON` командой `cmake -DBUILD_SHARED_LIBS=ON ..`.
Уже после пересборки появятся файлы `libhello.so` и `libprint.so`.


## Проект из двух типов библиотек

Команда `add_library` принимает параметр, устанавливающий явно тип библиотеки.
Для этого сразу же после имени цели передайте параметр (или ключевое слово) `SHARED` или `STATIC`.
В сценарии `CMakeLists.txt` ниже цель `hello` оформлена в виде разделяемой библиотеки, а `print` в виде архива.

```cmake
cmake_minimum_required(VERSION 3.22 FATAL_ERROR)
project(Hello LANGUAGES C)
add_library(hello SHARED hello.c)
add_library(print STATIC print.c)
add_executable(app main.c)
target_link_libraries(app hello)
target_link_libraries(app print)
```


## Улучшения проекта

Улучшим сценарий в `CMakeLists.txt` следующим образом:
* задокументируем;
* вынесем список файлов в переменные;
* воспользуемся общепринятым стилем кодирования;
* разделим файлы по каталогам.

<!-- Комментарии и команды -->
CMake предлагает специализированный язык программирования для решения задач сборки.
Этот язык имеет интересную особенность, которая отличает его от привычных нам языков.
Такие конструкции как переменные, условные выражения, циклы, объявление новой функции и все остальное сводится к вызовам команд.
Кроме команд в сценариях присутствуют только комментарии и пустые строки.
Если в строке присутствует символ `#`, то все идущие за ним символы рассматриваются как комментарии.
Комментарии игнорируются интерпретатором CMake.

```cmake
set(Foo a b c) # Значение Foo равно "a;b;c"
# Обработать подкаталог dir
add_subdirectory(dir)
```

<!-- Переменные -->
В CMake переменная играет важную роль в управлении процессом сборки.
В ней хранят пути, флаги, списки файлов и другие параметры.
Воспользуемся переменной и вынесем список файлов из команды:
```cmake
add_executable(app main.c hello.c print.c)
```

Ниже показан результат преобразования.
```cmake
set(SRC_APP
    main.c
    hello.c
    print.c
)
add_executable(app ${SRC_APP})
```

Команда `set` создает переменную.
Первым параметром идет имя переменной, а следующими -- ее значение.
В нашем случае переменная представляет список.
Ниже из переменной считывается значение.
Теперь добавление нового файла будет выглядеть как добавление новой строки в список, а параметры команды `add_executable` останутся нетронутыми.
Такой код проще сопровождать.
В ней разделены смысловые блоки по формированию списка файлов и созданию цели.

<!-- Оформление сценария -->
В программировании важную роль играет читаемость кода.
Один из способов достичь ее -- это придерживаться общих правил оформления кода.
Для сценариев CMake нет официального стандарта на этот счет, но существуют общепринятые правила.
Перечислим их:
* для отступов используют 2 или 4 пробела вместо символа табуляции;
* короткие команды помещают в одну строку; если они длинные, то разбивают на несколько строк с отступами;
* между логическими блоками добавляют пустую строку;
* комментарии пишут над кодом, а не справа;
* для переменных используют стиль `UPPER_CASE`, команды -- `lower_case`, цели -- `CamelCase` или `lower_case`.

<!-- Разделим файлы по каталогам -->
Любой проект начинается из небольшого количества файлов, но с течением времени разрастается до сотен и тысяч файлов.
Чтобы упростить сопровождение проекта, файлы группируют по подкаталогам.
Способы группировки отличаются для библиотек и приложений, зависят от размера проекта и предпочтений автора.
Здесь мы обратим внимание на группировку исходных файлов по целям, которым они принадлежат.
Для каждой цели выделяют отдельный подкаталог, в котором кроме исходных и заголовочных файлов содержится как минимум файл `CMakeLists.txt`, формирующий эту цель.
Подкаталоги с целями размещаются внутри подкаталога `src`.
В результате мы получаем следующую структуру каталогов:
```
cmake-project/
├── CMakeLists.txt
├── src/
│   ├── app/
│   │   ├── main.c
│   │   └── CMakeLists.txt
│   ├── hello/
│   │   ├── hello.c
│   │   ├── hello.h
│   │   └── CMakeLists.txt
│   ├── print/
│   │   ├── print.c
│   │   ├── print.h
│   │   └── CMakeLists.txt
│   └── CMakeLists.txt
└── build/
```

До группировки файлов правила управления сборкой размещались в одном файле -- `CMakeLists.txt`.
После группировки команды, формирующие цели `app`, `hello`, `print` переместятся из корневого в низлежащие сценарии `CMakeLists.txt`.
Команда `add_subdirectory` связывает разбросанные по каталогам файлы `CMakeLists.txt` в одно целое.
Она перенаправляет интерпретацию сценариев в каталог, указанный в ней как параметр.
Это ключевой инструмент для модульной организации проекта.

Содержимое новых `CMakeLists.txt`-файлов будет следующим:

```cmake
# ./CMakeLists.txt
cmake_minimum_required(VERSION 3.22 FATAL_ERROR)
project(Hello LANGUAGES C)
add_subdirectory(src)

# ./src/CMakeLists.txt
add_subdirectory(app)
add_subdirectory(hello)
add_subdirectory(print)

# ./src/hello/CMakeLists.txt
add_library(hello SHARED hello.c)
target_include_directories(hello PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

# ./src/print/CMakeLists.txt
add_library(print SHARED print.c)
target_include_directories(print PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
```

Команда `target_include_directories` указывает где компилятор должен искать заголовочные файлы для конкретной цели.
Заголовочные файлы лежат там же, где лежит `CMakeLists.txt`.
Стандартная переменная `CMAKE_CURRENT_SOURCE_DIR` содержит полный путь к каталогу текущего обрабатываемого `CMakeLists.txt`.
Ключевое слово `PUBLIC` определяет область видимости путей.
Эти пути будут использованы для сборки как самой цели, так и клиентами этой цели.


## Вопросы для самоконтроля


## Упражнения

<!--
Что такое заголовочный и исходный файлы?
-->
