# &#128293; GCC из командной строки

<!-- Что мы узнаем из этого раздела? -->
В этом разделе на простом примере мы увидим как собрать программу, используя компилятор `gcc` и командную строку.
В будущем эти знания понадобятся вам при исправлении таких ошибок компоновщика (линкера) как "undefined reference to ...".
Они не так многочисленны как ошибки компилятора, но время на их исправление уходит достаточно много.
Чтобы исправить их необходимо выйти за пределы языка программирования и переместиться на уровень сборки.

Здесь мы научимся:
* работать с утилитами `gcc`, `nm`, `ar`;
* собирать из командной строки запускаемый файл, статическую и разделяемую библиотеки;
* объединять компоненты программы в одно запускаемое приложение;


<!--
## Как работает компилятор

`gcc` -- это не компилятор, а управляющая оболочка.
В зависимости от переданных опций, она вызывает внутри себя компилятор, компоновщик, препроцессор, ассемблер, оптимизатор.
Сборка программ C/C++ состоит из нескольких этапов:
* препроцессинг;
* компиляция;
* ассемблирование;
* компоновка;
* оптимизация;
* генерация машинного кода.

`gcc` с помощью опций позволяет управлять этими этапами.
-->


## Компоненты программы

Готовое к запуску приложение состоит из исполняемых файлов.
Команда `ls` обычно подкрашивает такие файлы зеленым цветом.
Исполняемые файлы делятся на два типа:
* запускаемые файлы;
* разделяемые библиотеки.

Запускаемый файл, как говорит название, может быть запущен на исполнение, например, из командной строки.
В отличие от запускаемых файлов, разделяемая библиотека имеет несколько точек входа и предоставляют повторно используемую функциональность для нескольких запускаемых файлов.
Разделяемым библиотекам дают расширение `.so` (`.dll` в Windows), а запускаемые файлы обычно обходятся без расширений (или `.exe` в Windows).
Примерами расширяемых библиотек являются:
* стандартная библиотека Си libc(7) в файле `/lib/x86_64-linux-gnu/libc.so.6`;
* системная библиотека vdso(7) в файле `linux-vdso.so.1`;

Использование разделяемых библиотек дает следующие преимущества:
* удобство в обновлении программ;
* экономное расходование дисковой и оперативной памяти.

При сборке программы файлы с исходными кодами (если быть точнее, то объектные файлы) группируются по трем сущностям:
* запускаемым файлам;
* разделяемым библиотекам;
* архивам.

Архив -- это специальный файл, группирующий несколько объектных файлов в один.
В отличие от разделяемой библиотеки, содержимое архивного файла помещается внутрь запускаемых файлов и разделяемых библиотек.
Поэтому архив актуален только при сборке, и не входит в состав дистрибутива и не используется при запуске приложения.


## Пример простой программы

Напишем простую программу на языке программирования Си.
Она выводит сообщение "Hello, my friend!" в стандартный поток вывода.
Несмотря на то, что ее можно оформить в виде одной функции `main`, она искусственно разделена на три файла: `main.c`, `hello.c`, `print.c`.
Первый файл содержит основную функцию `main`, которая вызывает две функции:
1) `const char* hello_message()` возвращает строку приветствия и определена в файле `hello.c`;
2) `void print(const char*)` выводит переданную в аргумент строку и определена в файле `print.c`.

С последними двумя файлами реализаций связаны заголовочные файлы, куда вынесены объявления функций.
Содержимое файлов показано ниже или можете посмотреть последние версии файлов на GitHub [по ссылке](https://github.com/wolodyx/cmake-intro/blob/main/examples/exercise-1.1).

```
// hello.h
#ifndef HELLO_H
#define HELLO_H
const char* hello_message();
#endif // !HELLO_H

// hello.c
#include "hello.h"
static const char* s_hello_message = "Hello, my friend!";
const char* hello_message()
{
    return s_hello_message;
}

// print.h
#ifndef PRINT_H
#define PRINT_H
void print(const char* message);
#endif // !PRINT_H

// print.c
#include "print.h"
#include <stdio.h>
void print(const char* message)
{
    fprintf(stdout, "%s\n", message);
}

// main.c
#include "hello.h"
#include "print.h"
int main(int argc, char** argv)
{
    print(hello_message());
    return 0;
}
```

```{note}
Расширение `.c` файла указывает, что в нем содержится исходный код, написанный на Си.
Если вы пишете программу на C++, то следует выбрать расширения `.cpp` или `.cxx`.
```


## Сборка исполняемого файла

Соберите исполняемый файл с именем `executable` одной командой:
```
gcc -o executable main.c hello.c print.c
```
Опция `-o` требует аргумента -- имени выходного файла.
Если ее не указать, то выходной файл будет иметь тривиальное название `a.out`.
Далее следуют список файлов с исходными кодами программы.
Команду выше можно сократить, если воспользоваться подстановкой файлов в `bash`:
```
gcc -o executable *.c
```

На выходе появляется файл `executable`, которую можно запустить по относительному пути:
```
bob@pc:~$./executable
Hello, my friend!
```

```{warning}
Файл запускается по имени, только если он располагается в каталогах, перечисленных в системной переменной `PATH`.
В остальных случаях следует указывать путь к файлу, использую знаки косой черты.
Самый короткий способ -- это воспользоваться обозначением текущего каталога: `./executable`.
```

Утилита `gcc` -- это управляющая программа, вызывающая внутри себя сначала компилятор, затем компоновщик.
Компилятор для каждого файла с исходным кодом создает объектный файл, а компоновщик собирает объектные файлы в исполняемый файл.
Все это происходит в оперативной памяти и из артефактов сборки остается только конечный результат -- запускаемый файл.

```{figure} ./images2/executable.png
```

## Сборка разделяемой библиотеки

В этой части оформим нашу программу в виде двух исполняемых файлов: запускаемого (`executable`) и разделяемой библиотеки (`libprint_hello.so`).
Код из файла `main.c` попадает в запускаемый файл, а `hello.c` и `print.c` войдут в состав разделяемой библиотеки.

```{figure} ./images2/exe-so.png
```

Нужная нам конфигурация программы будет получена тремя командами.
Четвертая команда запустит программу на исполнение.
Разберем каждую из этих команд.
```bash
gcc -c -fPIC hello.c print.c
gcc -shared -o libhello_print.so *.o
gcc -o executable main.c -L$PWD -lhello_print
LD_LIBRARY_PATH=$PWD ./executable
```

Команда `gcc -c -fPIC hello.c print.c` скомпилирует файлы `hello.c` и `print.c` в объектные файлы `hello.o` и `print.o`.
Опция `-c` указыает на компиляцию.
Вторая опция `-fPIC` указывает компилятору создавать переносимый в адресном пространстве код (Position Independent Code).
Эта опция нужна для возможности в последующем собрать из объектных файлов разделяемую библиотеку.

Команда `gcc -shared -o libhello_print.so *.o` собирает из файлов с расширением `.o` разделяемую библиотеку с именем `libhello_print.so`.
Опция `-shared` указывает `gcc`, что выходной файл следует оформить в виде разделяемой библиотеки.

Третьей командой `gcc -o executable main.c -L$PWD -lhello_print` мы собираем запускаемый файл `executable`.
Для его сборки дополнительно указываем два аргумента опциями `-L` и `-l`.
Опция `-l` задает имя библиотеки, а `-L` -- путь к ней.
Путь следует задавать обязательно, если библиотека пользовательская.
Для системных библиотек путь необязателен.

<!-- Про именование разделяемых библиотек -->
Заметим, что имя библиотеки в командной строке и в файловой системе различаются.
По соглашению, файл с библиотекой `xyz` будет иметь название `libxyz.so`.
Название также может быть дополнено версией, как например, `libxyz.so.3.2.1`.
Более подробно о правилах именования библиотек и их организации в файловой системе в Linux можно ознакомиться [по ссылке](https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html).

<!-- Про запуск приложения с собственной несистемной разделяемой библиотекой -->
Обратим внимание, что теперь не получается запустить нашу программу как раньше по относительному имени:
```console
bob@pc:~$ ./executable
./executable: error while loading shared libraries: libhello_print.so: cannot open shared object file: No such file or directory
```
Поэтому перед запуском файла мы инициализируем переменную окружения `LD_LIBRARY_PATH` каталогом, где располагается наша разделяемая библиотека.
Зачем это нужно?
При запуске программы в дело вступает динамический компоновщик.
Это компонент операционной системы.
Его задача в том, чтобы собрать разбросанные на диске исполняемые файлы в одно целое в оперативной памяти.
По умолчанию он ищет разделяемые библиотеки в системных каталогах.
Если задана переменная окружения `LD_LIBRARY_PATH`, то он дополнительно ищет библиотеки в ее каталогах.

```{note}
Заметим, что при сборке программы тоже есть компоновщик.
Чтобы как-то различать их, им дают названия *статический и динамический компоновщики*.
```


## Сборка статической библиотеки

Альтернативой разделяемой библиотеке выступает *архив*, больше известная как *статическая библиотека* из программирования на Windows.
Архив, как и разделяемая библиотека, содержит набор функций вместе с объектными файлами.
В отличие от разделяемой библиотеки, архив не является исполняемым файлом.
Функции из архива включаются в исполняемые файлы при сборке программы статическим компоновщиком.
Поэтому архив актуален только на момент сборки и не может входить в состав дистрибутива.
Архив полезен тем, что ускоряет сборку и уменьшет фрагментацию диска из-за большого количества малых файлов.

Для управления архивом используют утилиту `ar`.
Эта утилита появилась на заре становления программирования, поэтому использует непривычные обозначения коротких опции без знака дефиса.
В реализации от GNU эти опции доступны и через дефис.

```{figure} ./images2/exe-a.png
```

Чтобы собрать программу и запустить ее выполним последовательно четыре команды:

```bash
gcc -c hello.c print.c
ar rcs libprint_hello.a print.o hello.o
gcc -L$PWD -o executable main.c -lprint_hello
./executable
```

Первая команда подготавливает два объектных файла, из которых уже вторая команда соберет архив.
Рассмотрим три опции:
* `c` подавляет информационный вывод о создании нового архива;
* `r` указыает, что необходимо добавить в архив содержимое указанных объектных файлов;
* `s` указывает, что необходимо перестроить таблицу внешних символов.

Третья команда, по аналогии выше, собирает запускаемый файл из файла `main.c`, компонуя его с архивом.

Запуск `executable` не требует указания расположения архива.
Удалите файл `libprint_hello.a` и запустите файл снова, чтобы удостоверится, что программа не требует для своего запуска этого файла.


## Вопросы для самоконтроля

1. Что означают опции `-c`, `-o`, `-shared`, `-fPIC` управляющей программы `gcc`?
1. Что означают переменные окружения `PWD`, `HOME`, `PATH`?
1. Что выдаст `gcc`, если ей также передать файл с расширением `.h`?
   А если передать файл, функции в котором не вызываются в программе?


## Упражнения

1. Найдите в системе все разделяемые библиотеки командой `find`. <!-- `find / -name lib*.so 2>/dev/null | less` -->
1. Соберите программу из файлов `main.c`, `hello.c`, `print.c` в следующих вариантах:
  * `libhello.so + libprint.so + executable`;
  * `libhello.so + libprint.a + executable`;
  * `libhello.a + libprint.so + executable`;
  * `libhello.a + libprint.a + executable`;
  * `libhello_print.a + executable`;
  * `libhello_print.so + executable`;
  * `libhello.so + executable`;
  * `libprint.so + executable`;
  * `executable`;


<!--
Команда `ar -t libprint_hello.a` выводит содержащихся в архиве список объектных файлов.
-->
